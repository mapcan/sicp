;(define (lookup-variable-value var env)
;  (define (env-loop env)
;    (define (scan vars vals)
;      (cond ((null? vars)
;             (env-loop (enclosing-environment env)))
;            ((eq? var (car vars))
;             (let ((val (car vals)))
;               (if (eq? val '*unassigned*)
;                 (error "Variable unassigned" var)
;                 val)))
;            (else (scan (cdr vars) (cdr vals)))))
;    (if (eq? env the-empty-environment)
;      (error "Unbound variable" var)
;      (let ((frame (first-frame env)))
;        (scan (frame-variables frame)
;              (frame-values frame)))))
;  (env-loop env))
(define (definition? exp)
  (newline)
  (display exp)
  (tagged-list? exp 'define))
(define (definition-variable exp)
  (if (symbol? (cadr exp))
    (cadr exp)
    (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp))
    (caddr exp)
    (make-lambda (cdadr exp)
                 (cddr exp))))
(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))
(define (tagged-list? exp tag)
  (if (pair? exp)
    (eq? (car exp) tag)
    false))
(define (definitions body)
  (filter definition? body))
(define (sequences body)
  (filter (lambda (x)
            (not (definition? x)))
          body))
(define (make-let-unassigned definitions)
  (map (lambda (x)
         (list (definition-variable x)
                     '(quote *unassigned*)))
       definitions))
(define (make-let-set definitions)
  (map (lambda (x)
         (list 'set!
               (definition-variable x)
               (definition-value x)))
       definitions))
(define (scan-out-defines block)
  (let ((defs (definitions block))
        (seqs (sequences block)))
    (append
      (append
        (list 'let)
        (cons
          (make-let-unassigned defs)
          (make-let-set defs)))
      seqs)))

(scan-out-defines
  '((define a 1) (define b 2) (display a) (display b)))
